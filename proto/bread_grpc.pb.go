// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.23.3
// source: proto/bread.proto

package bread

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueueServiceClient interface {
	AddClientToQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error)
	ShowWaitingQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error)
	DeleteClientFromQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) AddClientToQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error) {
	out := new(ClientsInQueue)
	err := c.cc.Invoke(ctx, "/bread.QueueService/AddClientToQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ShowWaitingQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error) {
	out := new(ClientsInQueue)
	err := c.cc.Invoke(ctx, "/bread.QueueService/ShowWaitingQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) DeleteClientFromQueue(ctx context.Context, in *ClientsInQueue, opts ...grpc.CallOption) (*ClientsInQueue, error) {
	out := new(ClientsInQueue)
	err := c.cc.Invoke(ctx, "/bread.QueueService/DeleteClientFromQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServiceServer is the server API for QueueService service.
// All implementations must embed UnimplementedQueueServiceServer
// for forward compatibility
type QueueServiceServer interface {
	AddClientToQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error)
	ShowWaitingQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error)
	DeleteClientFromQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error)
	mustEmbedUnimplementedQueueServiceServer()
}

// UnimplementedQueueServiceServer must be embedded to have forward compatible implementations.
type UnimplementedQueueServiceServer struct {
}

func (UnimplementedQueueServiceServer) AddClientToQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClientToQueue not implemented")
}
func (UnimplementedQueueServiceServer) ShowWaitingQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowWaitingQueue not implemented")
}
func (UnimplementedQueueServiceServer) DeleteClientFromQueue(context.Context, *ClientsInQueue) (*ClientsInQueue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClientFromQueue not implemented")
}
func (UnimplementedQueueServiceServer) mustEmbedUnimplementedQueueServiceServer() {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_AddClientToQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientsInQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).AddClientToQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.QueueService/AddClientToQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).AddClientToQueue(ctx, req.(*ClientsInQueue))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ShowWaitingQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientsInQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ShowWaitingQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.QueueService/ShowWaitingQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ShowWaitingQueue(ctx, req.(*ClientsInQueue))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_DeleteClientFromQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientsInQueue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).DeleteClientFromQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.QueueService/DeleteClientFromQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).DeleteClientFromQueue(ctx, req.(*ClientsInQueue))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddClientToQueue",
			Handler:    _QueueService_AddClientToQueue_Handler,
		},
		{
			MethodName: "ShowWaitingQueue",
			Handler:    _QueueService_ShowWaitingQueue_Handler,
		},
		{
			MethodName: "DeleteClientFromQueue",
			Handler:    _QueueService_DeleteClientFromQueue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

// MakeBreadClient is the client API for MakeBread service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MakeBreadClient interface {
	MakeBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	AddBreadToQueue(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
}

type makeBreadClient struct {
	cc grpc.ClientConnInterface
}

func NewMakeBreadClient(cc grpc.ClientConnInterface) MakeBreadClient {
	return &makeBreadClient{cc}
}

func (c *makeBreadClient) MakeBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, "/bread.MakeBread/MakeBread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *makeBreadClient) AddBreadToQueue(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, "/bread.MakeBread/AddBreadToQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MakeBreadServer is the server API for MakeBread service.
// All implementations must embed UnimplementedMakeBreadServer
// for forward compatibility
type MakeBreadServer interface {
	MakeBread(context.Context, *BreadRequest) (*BreadResponse, error)
	AddBreadToQueue(context.Context, *BreadRequest) (*BreadResponse, error)
	mustEmbedUnimplementedMakeBreadServer()
}

// UnimplementedMakeBreadServer must be embedded to have forward compatible implementations.
type UnimplementedMakeBreadServer struct {
}

func (UnimplementedMakeBreadServer) MakeBread(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeBread not implemented")
}
func (UnimplementedMakeBreadServer) AddBreadToQueue(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBreadToQueue not implemented")
}
func (UnimplementedMakeBreadServer) mustEmbedUnimplementedMakeBreadServer() {}

// UnsafeMakeBreadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MakeBreadServer will
// result in compilation errors.
type UnsafeMakeBreadServer interface {
	mustEmbedUnimplementedMakeBreadServer()
}

func RegisterMakeBreadServer(s grpc.ServiceRegistrar, srv MakeBreadServer) {
	s.RegisterService(&MakeBread_ServiceDesc, srv)
}

func _MakeBread_MakeBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MakeBreadServer).MakeBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.MakeBread/MakeBread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MakeBreadServer).MakeBread(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MakeBread_AddBreadToQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MakeBreadServer).AddBreadToQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.MakeBread/AddBreadToQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MakeBreadServer).AddBreadToQueue(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MakeBread_ServiceDesc is the grpc.ServiceDesc for MakeBread service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MakeBread_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.MakeBread",
	HandlerType: (*MakeBreadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MakeBread",
			Handler:    _MakeBread_MakeBread_Handler,
		},
		{
			MethodName: "AddBreadToQueue",
			Handler:    _MakeBread_AddBreadToQueue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

// CreateClientClient is the client API for CreateClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreateClientClient interface {
	CreateClient(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*ClientResponse, error)
}

type createClientClient struct {
	cc grpc.ClientConnInterface
}

func NewCreateClientClient(cc grpc.ClientConnInterface) CreateClientClient {
	return &createClientClient{cc}
}

func (c *createClientClient) CreateClient(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*ClientResponse, error) {
	out := new(ClientResponse)
	err := c.cc.Invoke(ctx, "/bread.CreateClient/CreateClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreateClientServer is the server API for CreateClient service.
// All implementations must embed UnimplementedCreateClientServer
// for forward compatibility
type CreateClientServer interface {
	CreateClient(context.Context, *ClientRequest) (*ClientResponse, error)
	mustEmbedUnimplementedCreateClientServer()
}

// UnimplementedCreateClientServer must be embedded to have forward compatible implementations.
type UnimplementedCreateClientServer struct {
}

func (UnimplementedCreateClientServer) CreateClient(context.Context, *ClientRequest) (*ClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClient not implemented")
}
func (UnimplementedCreateClientServer) mustEmbedUnimplementedCreateClientServer() {}

// UnsafeCreateClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreateClientServer will
// result in compilation errors.
type UnsafeCreateClientServer interface {
	mustEmbedUnimplementedCreateClientServer()
}

func RegisterCreateClientServer(s grpc.ServiceRegistrar, srv CreateClientServer) {
	s.RegisterService(&CreateClient_ServiceDesc, srv)
}

func _CreateClient_CreateClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreateClientServer).CreateClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.CreateClient/CreateClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreateClientServer).CreateClient(ctx, req.(*ClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CreateClient_ServiceDesc is the grpc.ServiceDesc for CreateClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreateClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.CreateClient",
	HandlerType: (*CreateClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateClient",
			Handler:    _CreateClient_CreateClient_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

// BakeryBreadServiceClient is the client API for BakeryBreadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BakeryBreadServiceClient interface {
	GetAvailableBreads(ctx context.Context, in *BakeryRequestList, opts ...grpc.CallOption) (*BakeryResponseList, error)
	CheckBreadQueue(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadQueueSize, error)
	BuyBreadFromQueue(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyResponse, error)
}

type bakeryBreadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBakeryBreadServiceClient(cc grpc.ClientConnInterface) BakeryBreadServiceClient {
	return &bakeryBreadServiceClient{cc}
}

func (c *bakeryBreadServiceClient) GetAvailableBreads(ctx context.Context, in *BakeryRequestList, opts ...grpc.CallOption) (*BakeryResponseList, error) {
	out := new(BakeryResponseList)
	err := c.cc.Invoke(ctx, "/bread.BakeryBreadService/GetAvailableBreads", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bakeryBreadServiceClient) CheckBreadQueue(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadQueueSize, error) {
	out := new(BreadQueueSize)
	err := c.cc.Invoke(ctx, "/bread.BakeryBreadService/CheckBreadQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bakeryBreadServiceClient) BuyBreadFromQueue(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyResponse, error) {
	out := new(BuyResponse)
	err := c.cc.Invoke(ctx, "/bread.BakeryBreadService/BuyBreadFromQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BakeryBreadServiceServer is the server API for BakeryBreadService service.
// All implementations must embed UnimplementedBakeryBreadServiceServer
// for forward compatibility
type BakeryBreadServiceServer interface {
	GetAvailableBreads(context.Context, *BakeryRequestList) (*BakeryResponseList, error)
	CheckBreadQueue(context.Context, *Empty) (*BreadQueueSize, error)
	BuyBreadFromQueue(context.Context, *BuyRequest) (*BuyResponse, error)
	mustEmbedUnimplementedBakeryBreadServiceServer()
}

// UnimplementedBakeryBreadServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBakeryBreadServiceServer struct {
}

func (UnimplementedBakeryBreadServiceServer) GetAvailableBreads(context.Context, *BakeryRequestList) (*BakeryResponseList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableBreads not implemented")
}
func (UnimplementedBakeryBreadServiceServer) CheckBreadQueue(context.Context, *Empty) (*BreadQueueSize, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBreadQueue not implemented")
}
func (UnimplementedBakeryBreadServiceServer) BuyBreadFromQueue(context.Context, *BuyRequest) (*BuyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyBreadFromQueue not implemented")
}
func (UnimplementedBakeryBreadServiceServer) mustEmbedUnimplementedBakeryBreadServiceServer() {}

// UnsafeBakeryBreadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BakeryBreadServiceServer will
// result in compilation errors.
type UnsafeBakeryBreadServiceServer interface {
	mustEmbedUnimplementedBakeryBreadServiceServer()
}

func RegisterBakeryBreadServiceServer(s grpc.ServiceRegistrar, srv BakeryBreadServiceServer) {
	s.RegisterService(&BakeryBreadService_ServiceDesc, srv)
}

func _BakeryBreadService_GetAvailableBreads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BakeryRequestList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BakeryBreadServiceServer).GetAvailableBreads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.BakeryBreadService/GetAvailableBreads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BakeryBreadServiceServer).GetAvailableBreads(ctx, req.(*BakeryRequestList))
	}
	return interceptor(ctx, in, info, handler)
}

func _BakeryBreadService_CheckBreadQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BakeryBreadServiceServer).CheckBreadQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.BakeryBreadService/CheckBreadQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BakeryBreadServiceServer).CheckBreadQueue(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BakeryBreadService_BuyBreadFromQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BakeryBreadServiceServer).BuyBreadFromQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bread.BakeryBreadService/BuyBreadFromQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BakeryBreadServiceServer).BuyBreadFromQueue(ctx, req.(*BuyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BakeryBreadService_ServiceDesc is the grpc.ServiceDesc for BakeryBreadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BakeryBreadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.BakeryBreadService",
	HandlerType: (*BakeryBreadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAvailableBreads",
			Handler:    _BakeryBreadService_GetAvailableBreads_Handler,
		},
		{
			MethodName: "CheckBreadQueue",
			Handler:    _BakeryBreadService_CheckBreadQueue_Handler,
		},
		{
			MethodName: "BuyBreadFromQueue",
			Handler:    _BakeryBreadService_BuyBreadFromQueue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}
