// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.19.6
// source: proto/bread.proto

package bread

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MakeBread_BakeBread_FullMethodName         = "/bread.MakeBread/BakeBread"
	MakeBread_SendBreadToBakery_FullMethodName = "/bread.MakeBread/SendBreadToBakery"
	MakeBread_MadeBreadStream_FullMethodName   = "/bread.MakeBread/MadeBreadStream"
)

// MakeBreadClient is the client API for MakeBread service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MakeBreadClient interface {
	BakeBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	SendBreadToBakery(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	MadeBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error)
}

type makeBreadClient struct {
	cc grpc.ClientConnInterface
}

func NewMakeBreadClient(cc grpc.ClientConnInterface) MakeBreadClient {
	return &makeBreadClient{cc}
}

func (c *makeBreadClient) BakeBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, MakeBread_BakeBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *makeBreadClient) SendBreadToBakery(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, MakeBread_SendBreadToBakery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *makeBreadClient) MadeBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MakeBread_ServiceDesc.Streams[0], MakeBread_MadeBreadStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BreadRequest, BreadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MakeBread_MadeBreadStreamClient = grpc.ServerStreamingClient[BreadResponse]

// MakeBreadServer is the server API for MakeBread service.
// All implementations must embed UnimplementedMakeBreadServer
// for forward compatibility.
type MakeBreadServer interface {
	BakeBread(context.Context, *BreadRequest) (*BreadResponse, error)
	SendBreadToBakery(context.Context, *BreadRequest) (*BreadResponse, error)
	MadeBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error
	mustEmbedUnimplementedMakeBreadServer()
}

// UnimplementedMakeBreadServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMakeBreadServer struct{}

func (UnimplementedMakeBreadServer) BakeBread(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BakeBread not implemented")
}
func (UnimplementedMakeBreadServer) SendBreadToBakery(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendBreadToBakery not implemented")
}
func (UnimplementedMakeBreadServer) MadeBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error {
	return status.Error(codes.Unimplemented, "method MadeBreadStream not implemented")
}
func (UnimplementedMakeBreadServer) mustEmbedUnimplementedMakeBreadServer() {}
func (UnimplementedMakeBreadServer) testEmbeddedByValue()                   {}

// UnsafeMakeBreadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MakeBreadServer will
// result in compilation errors.
type UnsafeMakeBreadServer interface {
	mustEmbedUnimplementedMakeBreadServer()
}

func RegisterMakeBreadServer(s grpc.ServiceRegistrar, srv MakeBreadServer) {
	// If the following call panics, it indicates UnimplementedMakeBreadServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MakeBread_ServiceDesc, srv)
}

func _MakeBread_BakeBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MakeBreadServer).BakeBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MakeBread_BakeBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MakeBreadServer).BakeBread(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MakeBread_SendBreadToBakery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MakeBreadServer).SendBreadToBakery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MakeBread_SendBreadToBakery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MakeBreadServer).SendBreadToBakery(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MakeBread_MadeBreadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BreadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MakeBreadServer).MadeBreadStream(m, &grpc.GenericServerStream[BreadRequest, BreadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MakeBread_MadeBreadStreamServer = grpc.ServerStreamingServer[BreadResponse]

// MakeBread_ServiceDesc is the grpc.ServiceDesc for MakeBread service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MakeBread_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.MakeBread",
	HandlerType: (*MakeBreadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BakeBread",
			Handler:    _MakeBread_BakeBread_Handler,
		},
		{
			MethodName: "SendBreadToBakery",
			Handler:    _MakeBread_SendBreadToBakery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MadeBreadStream",
			Handler:       _MakeBread_MadeBreadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	CheckInventory_CheckBreadInventory_FullMethodName       = "/bread.CheckInventory/CheckBreadInventory"
	CheckInventory_CheckBreadInventoryStream_FullMethodName = "/bread.CheckInventory/CheckBreadInventoryStream"
)

// CheckInventoryClient is the client API for CheckInventory service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CheckInventoryClient interface {
	CheckBreadInventory(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	CheckBreadInventoryStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error)
}

type checkInventoryClient struct {
	cc grpc.ClientConnInterface
}

func NewCheckInventoryClient(cc grpc.ClientConnInterface) CheckInventoryClient {
	return &checkInventoryClient{cc}
}

func (c *checkInventoryClient) CheckBreadInventory(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, CheckInventory_CheckBreadInventory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checkInventoryClient) CheckBreadInventoryStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CheckInventory_ServiceDesc.Streams[0], CheckInventory_CheckBreadInventoryStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BreadRequest, BreadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CheckInventory_CheckBreadInventoryStreamClient = grpc.ServerStreamingClient[BreadResponse]

// CheckInventoryServer is the server API for CheckInventory service.
// All implementations must embed UnimplementedCheckInventoryServer
// for forward compatibility.
type CheckInventoryServer interface {
	CheckBreadInventory(context.Context, *BreadRequest) (*BreadResponse, error)
	CheckBreadInventoryStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error
	mustEmbedUnimplementedCheckInventoryServer()
}

// UnimplementedCheckInventoryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCheckInventoryServer struct{}

func (UnimplementedCheckInventoryServer) CheckBreadInventory(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckBreadInventory not implemented")
}
func (UnimplementedCheckInventoryServer) CheckBreadInventoryStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error {
	return status.Error(codes.Unimplemented, "method CheckBreadInventoryStream not implemented")
}
func (UnimplementedCheckInventoryServer) mustEmbedUnimplementedCheckInventoryServer() {}
func (UnimplementedCheckInventoryServer) testEmbeddedByValue()                        {}

// UnsafeCheckInventoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CheckInventoryServer will
// result in compilation errors.
type UnsafeCheckInventoryServer interface {
	mustEmbedUnimplementedCheckInventoryServer()
}

func RegisterCheckInventoryServer(s grpc.ServiceRegistrar, srv CheckInventoryServer) {
	// If the following call panics, it indicates UnimplementedCheckInventoryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CheckInventory_ServiceDesc, srv)
}

func _CheckInventory_CheckBreadInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CheckInventoryServer).CheckBreadInventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CheckInventory_CheckBreadInventory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CheckInventoryServer).CheckBreadInventory(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CheckInventory_CheckBreadInventoryStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BreadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CheckInventoryServer).CheckBreadInventoryStream(m, &grpc.GenericServerStream[BreadRequest, BreadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CheckInventory_CheckBreadInventoryStreamServer = grpc.ServerStreamingServer[BreadResponse]

// CheckInventory_ServiceDesc is the grpc.ServiceDesc for CheckInventory service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CheckInventory_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.CheckInventory",
	HandlerType: (*CheckInventoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckBreadInventory",
			Handler:    _CheckInventory_CheckBreadInventory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CheckBreadInventoryStream",
			Handler:       _CheckInventory_CheckBreadInventoryStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	BuyBread_BuyBread_FullMethodName       = "/bread.BuyBread/BuyBread"
	BuyBread_BuyBreadStream_FullMethodName = "/bread.BuyBread/BuyBreadStream"
)

// BuyBreadClient is the client API for BuyBread service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuyBreadClient interface {
	BuyBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	BuyBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error)
}

type buyBreadClient struct {
	cc grpc.ClientConnInterface
}

func NewBuyBreadClient(cc grpc.ClientConnInterface) BuyBreadClient {
	return &buyBreadClient{cc}
}

func (c *buyBreadClient) BuyBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, BuyBread_BuyBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buyBreadClient) BuyBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BuyBread_ServiceDesc.Streams[0], BuyBread_BuyBreadStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BreadRequest, BreadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuyBread_BuyBreadStreamClient = grpc.ServerStreamingClient[BreadResponse]

// BuyBreadServer is the server API for BuyBread service.
// All implementations must embed UnimplementedBuyBreadServer
// for forward compatibility.
type BuyBreadServer interface {
	BuyBread(context.Context, *BreadRequest) (*BreadResponse, error)
	BuyBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error
	mustEmbedUnimplementedBuyBreadServer()
}

// UnimplementedBuyBreadServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuyBreadServer struct{}

func (UnimplementedBuyBreadServer) BuyBread(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BuyBread not implemented")
}
func (UnimplementedBuyBreadServer) BuyBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error {
	return status.Error(codes.Unimplemented, "method BuyBreadStream not implemented")
}
func (UnimplementedBuyBreadServer) mustEmbedUnimplementedBuyBreadServer() {}
func (UnimplementedBuyBreadServer) testEmbeddedByValue()                  {}

// UnsafeBuyBreadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuyBreadServer will
// result in compilation errors.
type UnsafeBuyBreadServer interface {
	mustEmbedUnimplementedBuyBreadServer()
}

func RegisterBuyBreadServer(s grpc.ServiceRegistrar, srv BuyBreadServer) {
	// If the following call panics, it indicates UnimplementedBuyBreadServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BuyBread_ServiceDesc, srv)
}

func _BuyBread_BuyBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuyBreadServer).BuyBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuyBread_BuyBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuyBreadServer).BuyBread(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuyBread_BuyBreadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BreadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuyBreadServer).BuyBreadStream(m, &grpc.GenericServerStream[BreadRequest, BreadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuyBread_BuyBreadStreamServer = grpc.ServerStreamingServer[BreadResponse]

// BuyBread_ServiceDesc is the grpc.ServiceDesc for BuyBread service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuyBread_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.BuyBread",
	HandlerType: (*BuyBreadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuyBread",
			Handler:    _BuyBread_BuyBread_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BuyBreadStream",
			Handler:       _BuyBread_BuyBreadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	BuyOrderService_BuyOrder_FullMethodName       = "/bread.BuyOrderService/BuyOrder"
	BuyOrderService_BuyOrderStream_FullMethodName = "/bread.BuyOrderService/BuyOrderStream"
)

// BuyOrderServiceClient is the client API for BuyOrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuyOrderServiceClient interface {
	BuyOrder(ctx context.Context, in *BuyOrderRequest, opts ...grpc.CallOption) (*BuyOrderResponse, error)
	BuyOrderStream(ctx context.Context, in *BuyOrderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuyOrderResponse], error)
}

type buyOrderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBuyOrderServiceClient(cc grpc.ClientConnInterface) BuyOrderServiceClient {
	return &buyOrderServiceClient{cc}
}

func (c *buyOrderServiceClient) BuyOrder(ctx context.Context, in *BuyOrderRequest, opts ...grpc.CallOption) (*BuyOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyOrderResponse)
	err := c.cc.Invoke(ctx, BuyOrderService_BuyOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buyOrderServiceClient) BuyOrderStream(ctx context.Context, in *BuyOrderRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuyOrderResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BuyOrderService_ServiceDesc.Streams[0], BuyOrderService_BuyOrderStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BuyOrderRequest, BuyOrderResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuyOrderService_BuyOrderStreamClient = grpc.ServerStreamingClient[BuyOrderResponse]

// BuyOrderServiceServer is the server API for BuyOrderService service.
// All implementations must embed UnimplementedBuyOrderServiceServer
// for forward compatibility.
type BuyOrderServiceServer interface {
	BuyOrder(context.Context, *BuyOrderRequest) (*BuyOrderResponse, error)
	BuyOrderStream(*BuyOrderRequest, grpc.ServerStreamingServer[BuyOrderResponse]) error
	mustEmbedUnimplementedBuyOrderServiceServer()
}

// UnimplementedBuyOrderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuyOrderServiceServer struct{}

func (UnimplementedBuyOrderServiceServer) BuyOrder(context.Context, *BuyOrderRequest) (*BuyOrderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BuyOrder not implemented")
}
func (UnimplementedBuyOrderServiceServer) BuyOrderStream(*BuyOrderRequest, grpc.ServerStreamingServer[BuyOrderResponse]) error {
	return status.Error(codes.Unimplemented, "method BuyOrderStream not implemented")
}
func (UnimplementedBuyOrderServiceServer) mustEmbedUnimplementedBuyOrderServiceServer() {}
func (UnimplementedBuyOrderServiceServer) testEmbeddedByValue()                         {}

// UnsafeBuyOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuyOrderServiceServer will
// result in compilation errors.
type UnsafeBuyOrderServiceServer interface {
	mustEmbedUnimplementedBuyOrderServiceServer()
}

func RegisterBuyOrderServiceServer(s grpc.ServiceRegistrar, srv BuyOrderServiceServer) {
	// If the following call panics, it indicates UnimplementedBuyOrderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BuyOrderService_ServiceDesc, srv)
}

func _BuyOrderService_BuyOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuyOrderServiceServer).BuyOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuyOrderService_BuyOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuyOrderServiceServer).BuyOrder(ctx, req.(*BuyOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuyOrderService_BuyOrderStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BuyOrderRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuyOrderServiceServer).BuyOrderStream(m, &grpc.GenericServerStream[BuyOrderRequest, BuyOrderResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuyOrderService_BuyOrderStreamServer = grpc.ServerStreamingServer[BuyOrderResponse]

// BuyOrderService_ServiceDesc is the grpc.ServiceDesc for BuyOrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuyOrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.BuyOrderService",
	HandlerType: (*BuyOrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuyOrder",
			Handler:    _BuyOrderService_BuyOrder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BuyOrderStream",
			Handler:       _BuyOrderService_BuyOrderStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	RemoveOldBread_RemoveBread_FullMethodName       = "/bread.RemoveOldBread/RemoveBread"
	RemoveOldBread_RemoveBreadStream_FullMethodName = "/bread.RemoveOldBread/RemoveBreadStream"
)

// RemoveOldBreadClient is the client API for RemoveOldBread service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RemoveOldBreadClient interface {
	RemoveBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	RemoveBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error)
}

type removeOldBreadClient struct {
	cc grpc.ClientConnInterface
}

func NewRemoveOldBreadClient(cc grpc.ClientConnInterface) RemoveOldBreadClient {
	return &removeOldBreadClient{cc}
}

func (c *removeOldBreadClient) RemoveBread(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, RemoveOldBread_RemoveBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *removeOldBreadClient) RemoveBreadStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RemoveOldBread_ServiceDesc.Streams[0], RemoveOldBread_RemoveBreadStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BreadRequest, BreadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoveOldBread_RemoveBreadStreamClient = grpc.ServerStreamingClient[BreadResponse]

// RemoveOldBreadServer is the server API for RemoveOldBread service.
// All implementations must embed UnimplementedRemoveOldBreadServer
// for forward compatibility.
type RemoveOldBreadServer interface {
	RemoveBread(context.Context, *BreadRequest) (*BreadResponse, error)
	RemoveBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error
	mustEmbedUnimplementedRemoveOldBreadServer()
}

// UnimplementedRemoveOldBreadServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRemoveOldBreadServer struct{}

func (UnimplementedRemoveOldBreadServer) RemoveBread(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveBread not implemented")
}
func (UnimplementedRemoveOldBreadServer) RemoveBreadStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error {
	return status.Error(codes.Unimplemented, "method RemoveBreadStream not implemented")
}
func (UnimplementedRemoveOldBreadServer) mustEmbedUnimplementedRemoveOldBreadServer() {}
func (UnimplementedRemoveOldBreadServer) testEmbeddedByValue()                        {}

// UnsafeRemoveOldBreadServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RemoveOldBreadServer will
// result in compilation errors.
type UnsafeRemoveOldBreadServer interface {
	mustEmbedUnimplementedRemoveOldBreadServer()
}

func RegisterRemoveOldBreadServer(s grpc.ServiceRegistrar, srv RemoveOldBreadServer) {
	// If the following call panics, it indicates UnimplementedRemoveOldBreadServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RemoveOldBread_ServiceDesc, srv)
}

func _RemoveOldBread_RemoveBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RemoveOldBreadServer).RemoveBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RemoveOldBread_RemoveBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RemoveOldBreadServer).RemoveBread(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RemoveOldBread_RemoveBreadStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BreadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RemoveOldBreadServer).RemoveBreadStream(m, &grpc.GenericServerStream[BreadRequest, BreadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RemoveOldBread_RemoveBreadStreamServer = grpc.ServerStreamingServer[BreadResponse]

// RemoveOldBread_ServiceDesc is the grpc.ServiceDesc for RemoveOldBread service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RemoveOldBread_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.RemoveOldBread",
	HandlerType: (*RemoveOldBreadServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RemoveBread",
			Handler:    _RemoveOldBread_RemoveBread_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RemoveBreadStream",
			Handler:       _RemoveOldBread_RemoveBreadStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	MakeOrderService_MakeOrder_FullMethodName       = "/bread.MakeOrderService/MakeOrder"
	MakeOrderService_MakeOrderStream_FullMethodName = "/bread.MakeOrderService/MakeOrderStream"
)

// MakeOrderServiceClient is the client API for MakeOrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MakeOrderServiceClient interface {
	MakeOrder(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error)
	MakeOrderStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error)
}

type makeOrderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMakeOrderServiceClient(cc grpc.ClientConnInterface) MakeOrderServiceClient {
	return &makeOrderServiceClient{cc}
}

func (c *makeOrderServiceClient) MakeOrder(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (*BreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadResponse)
	err := c.cc.Invoke(ctx, MakeOrderService_MakeOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *makeOrderServiceClient) MakeOrderStream(ctx context.Context, in *BreadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BreadResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MakeOrderService_ServiceDesc.Streams[0], MakeOrderService_MakeOrderStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BreadRequest, BreadResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MakeOrderService_MakeOrderStreamClient = grpc.ServerStreamingClient[BreadResponse]

// MakeOrderServiceServer is the server API for MakeOrderService service.
// All implementations must embed UnimplementedMakeOrderServiceServer
// for forward compatibility.
type MakeOrderServiceServer interface {
	MakeOrder(context.Context, *BreadRequest) (*BreadResponse, error)
	MakeOrderStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error
	mustEmbedUnimplementedMakeOrderServiceServer()
}

// UnimplementedMakeOrderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMakeOrderServiceServer struct{}

func (UnimplementedMakeOrderServiceServer) MakeOrder(context.Context, *BreadRequest) (*BreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MakeOrder not implemented")
}
func (UnimplementedMakeOrderServiceServer) MakeOrderStream(*BreadRequest, grpc.ServerStreamingServer[BreadResponse]) error {
	return status.Error(codes.Unimplemented, "method MakeOrderStream not implemented")
}
func (UnimplementedMakeOrderServiceServer) mustEmbedUnimplementedMakeOrderServiceServer() {}
func (UnimplementedMakeOrderServiceServer) testEmbeddedByValue()                          {}

// UnsafeMakeOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MakeOrderServiceServer will
// result in compilation errors.
type UnsafeMakeOrderServiceServer interface {
	mustEmbedUnimplementedMakeOrderServiceServer()
}

func RegisterMakeOrderServiceServer(s grpc.ServiceRegistrar, srv MakeOrderServiceServer) {
	// If the following call panics, it indicates UnimplementedMakeOrderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MakeOrderService_ServiceDesc, srv)
}

func _MakeOrderService_MakeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MakeOrderServiceServer).MakeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MakeOrderService_MakeOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MakeOrderServiceServer).MakeOrder(ctx, req.(*BreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MakeOrderService_MakeOrderStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BreadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MakeOrderServiceServer).MakeOrderStream(m, &grpc.GenericServerStream[BreadRequest, BreadResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MakeOrderService_MakeOrderStreamServer = grpc.ServerStreamingServer[BreadResponse]

// MakeOrderService_ServiceDesc is the grpc.ServiceDesc for MakeOrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MakeOrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.MakeOrderService",
	HandlerType: (*MakeOrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MakeOrder",
			Handler:    _MakeOrderService_MakeOrder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MakeOrderStream",
			Handler:       _MakeOrderService_MakeOrderStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/bread.proto",
}

const (
	AdminService_GetDashboardStats_FullMethodName = "/bread.AdminService/GetDashboardStats"
	AdminService_GetAllCustomers_FullMethodName   = "/bread.AdminService/GetAllCustomers"
	AdminService_GetAllBreadMakers_FullMethodName = "/bread.AdminService/GetAllBreadMakers"
	AdminService_GetAllBread_FullMethodName       = "/bread.AdminService/GetAllBread"
	AdminService_GetBreadById_FullMethodName      = "/bread.AdminService/GetBreadById"
	AdminService_CreateBread_FullMethodName       = "/bread.AdminService/CreateBread"
	AdminService_UpdateBread_FullMethodName       = "/bread.AdminService/UpdateBread"
	AdminService_DeleteBread_FullMethodName       = "/bread.AdminService/DeleteBread"
	AdminService_GetLowStockAlerts_FullMethodName = "/bread.AdminService/GetLowStockAlerts"
	AdminService_UpdateOrderStatus_FullMethodName = "/bread.AdminService/UpdateOrderStatus"
	AdminService_GetCustomerOrders_FullMethodName = "/bread.AdminService/GetCustomerOrders"
	AdminService_GetMakerOrders_FullMethodName    = "/bread.AdminService/GetMakerOrders"
	AdminService_GetAllOrders_FullMethodName      = "/bread.AdminService/GetAllOrders"
	AdminService_GetAllMakeOrders_FullMethodName  = "/bread.AdminService/GetAllMakeOrders"
)

// AdminServiceClient is the client API for AdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Admin Service
type AdminServiceClient interface {
	GetDashboardStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DashboardStats, error)
	GetAllCustomers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CustomerList, error)
	GetAllBreadMakers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadMakerList, error)
	GetAllBread(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadList, error)
	GetBreadById(ctx context.Context, in *BreadIdRequest, opts ...grpc.CallOption) (*Bread, error)
	CreateBread(ctx context.Context, in *CreateBreadRequest, opts ...grpc.CallOption) (*Bread, error)
	UpdateBread(ctx context.Context, in *UpdateBreadRequest, opts ...grpc.CallOption) (*Bread, error)
	DeleteBread(ctx context.Context, in *DeleteBreadRequest, opts ...grpc.CallOption) (*Empty, error)
	GetLowStockAlerts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadList, error)
	UpdateOrderStatus(ctx context.Context, in *UpdateOrderStatusRequest, opts ...grpc.CallOption) (*BuyOrder, error)
	GetCustomerOrders(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerOrdersResponse, error)
	GetMakerOrders(ctx context.Context, in *BreadMakerIdRequest, opts ...grpc.CallOption) (*MakerOrdersResponse, error)
	GetAllOrders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BuyOrderList, error)
	GetAllMakeOrders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MakeOrderList, error)
}

type adminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminServiceClient(cc grpc.ClientConnInterface) AdminServiceClient {
	return &adminServiceClient{cc}
}

func (c *adminServiceClient) GetDashboardStats(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DashboardStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DashboardStats)
	err := c.cc.Invoke(ctx, AdminService_GetDashboardStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAllCustomers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CustomerList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerList)
	err := c.cc.Invoke(ctx, AdminService_GetAllCustomers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAllBreadMakers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadMakerList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadMakerList)
	err := c.cc.Invoke(ctx, AdminService_GetAllBreadMakers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAllBread(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadList)
	err := c.cc.Invoke(ctx, AdminService_GetAllBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetBreadById(ctx context.Context, in *BreadIdRequest, opts ...grpc.CallOption) (*Bread, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bread)
	err := c.cc.Invoke(ctx, AdminService_GetBreadById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) CreateBread(ctx context.Context, in *CreateBreadRequest, opts ...grpc.CallOption) (*Bread, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bread)
	err := c.cc.Invoke(ctx, AdminService_CreateBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateBread(ctx context.Context, in *UpdateBreadRequest, opts ...grpc.CallOption) (*Bread, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Bread)
	err := c.cc.Invoke(ctx, AdminService_UpdateBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) DeleteBread(ctx context.Context, in *DeleteBreadRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, AdminService_DeleteBread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetLowStockAlerts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BreadList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BreadList)
	err := c.cc.Invoke(ctx, AdminService_GetLowStockAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateOrderStatus(ctx context.Context, in *UpdateOrderStatusRequest, opts ...grpc.CallOption) (*BuyOrder, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyOrder)
	err := c.cc.Invoke(ctx, AdminService_UpdateOrderStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetCustomerOrders(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerOrdersResponse)
	err := c.cc.Invoke(ctx, AdminService_GetCustomerOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetMakerOrders(ctx context.Context, in *BreadMakerIdRequest, opts ...grpc.CallOption) (*MakerOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MakerOrdersResponse)
	err := c.cc.Invoke(ctx, AdminService_GetMakerOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAllOrders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BuyOrderList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyOrderList)
	err := c.cc.Invoke(ctx, AdminService_GetAllOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAllMakeOrders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MakeOrderList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MakeOrderList)
	err := c.cc.Invoke(ctx, AdminService_GetAllMakeOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServiceServer is the server API for AdminService service.
// All implementations must embed UnimplementedAdminServiceServer
// for forward compatibility.
//
// Admin Service
type AdminServiceServer interface {
	GetDashboardStats(context.Context, *Empty) (*DashboardStats, error)
	GetAllCustomers(context.Context, *Empty) (*CustomerList, error)
	GetAllBreadMakers(context.Context, *Empty) (*BreadMakerList, error)
	GetAllBread(context.Context, *Empty) (*BreadList, error)
	GetBreadById(context.Context, *BreadIdRequest) (*Bread, error)
	CreateBread(context.Context, *CreateBreadRequest) (*Bread, error)
	UpdateBread(context.Context, *UpdateBreadRequest) (*Bread, error)
	DeleteBread(context.Context, *DeleteBreadRequest) (*Empty, error)
	GetLowStockAlerts(context.Context, *Empty) (*BreadList, error)
	UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*BuyOrder, error)
	GetCustomerOrders(context.Context, *CustomerIdRequest) (*CustomerOrdersResponse, error)
	GetMakerOrders(context.Context, *BreadMakerIdRequest) (*MakerOrdersResponse, error)
	GetAllOrders(context.Context, *Empty) (*BuyOrderList, error)
	GetAllMakeOrders(context.Context, *Empty) (*MakeOrderList, error)
	mustEmbedUnimplementedAdminServiceServer()
}

// UnimplementedAdminServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminServiceServer struct{}

func (UnimplementedAdminServiceServer) GetDashboardStats(context.Context, *Empty) (*DashboardStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDashboardStats not implemented")
}
func (UnimplementedAdminServiceServer) GetAllCustomers(context.Context, *Empty) (*CustomerList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllCustomers not implemented")
}
func (UnimplementedAdminServiceServer) GetAllBreadMakers(context.Context, *Empty) (*BreadMakerList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllBreadMakers not implemented")
}
func (UnimplementedAdminServiceServer) GetAllBread(context.Context, *Empty) (*BreadList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllBread not implemented")
}
func (UnimplementedAdminServiceServer) GetBreadById(context.Context, *BreadIdRequest) (*Bread, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBreadById not implemented")
}
func (UnimplementedAdminServiceServer) CreateBread(context.Context, *CreateBreadRequest) (*Bread, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBread not implemented")
}
func (UnimplementedAdminServiceServer) UpdateBread(context.Context, *UpdateBreadRequest) (*Bread, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBread not implemented")
}
func (UnimplementedAdminServiceServer) DeleteBread(context.Context, *DeleteBreadRequest) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteBread not implemented")
}
func (UnimplementedAdminServiceServer) GetLowStockAlerts(context.Context, *Empty) (*BreadList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLowStockAlerts not implemented")
}
func (UnimplementedAdminServiceServer) UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*BuyOrder, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateOrderStatus not implemented")
}
func (UnimplementedAdminServiceServer) GetCustomerOrders(context.Context, *CustomerIdRequest) (*CustomerOrdersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCustomerOrders not implemented")
}
func (UnimplementedAdminServiceServer) GetMakerOrders(context.Context, *BreadMakerIdRequest) (*MakerOrdersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMakerOrders not implemented")
}
func (UnimplementedAdminServiceServer) GetAllOrders(context.Context, *Empty) (*BuyOrderList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllOrders not implemented")
}
func (UnimplementedAdminServiceServer) GetAllMakeOrders(context.Context, *Empty) (*MakeOrderList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllMakeOrders not implemented")
}
func (UnimplementedAdminServiceServer) mustEmbedUnimplementedAdminServiceServer() {}
func (UnimplementedAdminServiceServer) testEmbeddedByValue()                      {}

// UnsafeAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServiceServer will
// result in compilation errors.
type UnsafeAdminServiceServer interface {
	mustEmbedUnimplementedAdminServiceServer()
}

func RegisterAdminServiceServer(s grpc.ServiceRegistrar, srv AdminServiceServer) {
	// If the following call panics, it indicates UnimplementedAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AdminService_ServiceDesc, srv)
}

func _AdminService_GetDashboardStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetDashboardStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetDashboardStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetDashboardStats(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAllCustomers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAllCustomers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAllCustomers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAllCustomers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAllBreadMakers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAllBreadMakers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAllBreadMakers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAllBreadMakers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAllBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAllBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAllBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAllBread(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetBreadById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetBreadById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetBreadById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetBreadById(ctx, req.(*BreadIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_CreateBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).CreateBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_CreateBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).CreateBread(ctx, req.(*CreateBreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateBread(ctx, req.(*UpdateBreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_DeleteBread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).DeleteBread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_DeleteBread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).DeleteBread(ctx, req.(*DeleteBreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetLowStockAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetLowStockAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetLowStockAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetLowStockAlerts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateOrderStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrderStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateOrderStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateOrderStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateOrderStatus(ctx, req.(*UpdateOrderStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetCustomerOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetCustomerOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetCustomerOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetCustomerOrders(ctx, req.(*CustomerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetMakerOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreadMakerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetMakerOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetMakerOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetMakerOrders(ctx, req.(*BreadMakerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAllOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAllOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAllOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAllOrders(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAllMakeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAllMakeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAllMakeOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAllMakeOrders(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// AdminService_ServiceDesc is the grpc.ServiceDesc for AdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.AdminService",
	HandlerType: (*AdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDashboardStats",
			Handler:    _AdminService_GetDashboardStats_Handler,
		},
		{
			MethodName: "GetAllCustomers",
			Handler:    _AdminService_GetAllCustomers_Handler,
		},
		{
			MethodName: "GetAllBreadMakers",
			Handler:    _AdminService_GetAllBreadMakers_Handler,
		},
		{
			MethodName: "GetAllBread",
			Handler:    _AdminService_GetAllBread_Handler,
		},
		{
			MethodName: "GetBreadById",
			Handler:    _AdminService_GetBreadById_Handler,
		},
		{
			MethodName: "CreateBread",
			Handler:    _AdminService_CreateBread_Handler,
		},
		{
			MethodName: "UpdateBread",
			Handler:    _AdminService_UpdateBread_Handler,
		},
		{
			MethodName: "DeleteBread",
			Handler:    _AdminService_DeleteBread_Handler,
		},
		{
			MethodName: "GetLowStockAlerts",
			Handler:    _AdminService_GetLowStockAlerts_Handler,
		},
		{
			MethodName: "UpdateOrderStatus",
			Handler:    _AdminService_UpdateOrderStatus_Handler,
		},
		{
			MethodName: "GetCustomerOrders",
			Handler:    _AdminService_GetCustomerOrders_Handler,
		},
		{
			MethodName: "GetMakerOrders",
			Handler:    _AdminService_GetMakerOrders_Handler,
		},
		{
			MethodName: "GetAllOrders",
			Handler:    _AdminService_GetAllOrders_Handler,
		},
		{
			MethodName: "GetAllMakeOrders",
			Handler:    _AdminService_GetAllMakeOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

const (
	AuthService_AdminLogin_FullMethodName      = "/bread.AuthService/AdminLogin"
	AuthService_CustomerLogin_FullMethodName   = "/bread.AuthService/CustomerLogin"
	AuthService_ValidateToken_FullMethodName   = "/bread.AuthService/ValidateToken"
	AuthService_CreateAdminUser_FullMethodName = "/bread.AuthService/CreateAdminUser"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Auth Service
type AuthServiceClient interface {
	AdminLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	CustomerLogin(ctx context.Context, in *CustomerLoginRequest, opts ...grpc.CallOption) (*CustomerLoginResponse, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	CreateAdminUser(ctx context.Context, in *CreateAdminUserRequest, opts ...grpc.CallOption) (*AdminUser, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) AdminLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_AdminLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CustomerLogin(ctx context.Context, in *CustomerLoginRequest, opts ...grpc.CallOption) (*CustomerLoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerLoginResponse)
	err := c.cc.Invoke(ctx, AuthService_CustomerLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAdminUser(ctx context.Context, in *CreateAdminUserRequest, opts ...grpc.CallOption) (*AdminUser, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUser)
	err := c.cc.Invoke(ctx, AuthService_CreateAdminUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// Auth Service
type AuthServiceServer interface {
	AdminLogin(context.Context, *LoginRequest) (*LoginResponse, error)
	CustomerLogin(context.Context, *CustomerLoginRequest) (*CustomerLoginResponse, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	CreateAdminUser(context.Context, *CreateAdminUserRequest) (*AdminUser, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) AdminLogin(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AdminLogin not implemented")
}
func (UnimplementedAuthServiceServer) CustomerLogin(context.Context, *CustomerLoginRequest) (*CustomerLoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CustomerLogin not implemented")
}
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedAuthServiceServer) CreateAdminUser(context.Context, *CreateAdminUserRequest) (*AdminUser, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAdminUser not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call panics, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_AdminLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AdminLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_AdminLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AdminLogin(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CustomerLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CustomerLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_CustomerLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CustomerLogin(ctx, req.(*CustomerLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAdminUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAdminUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAdminUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_CreateAdminUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAdminUser(ctx, req.(*CreateAdminUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AdminLogin",
			Handler:    _AuthService_AdminLogin_Handler,
		},
		{
			MethodName: "CustomerLogin",
			Handler:    _AuthService_CustomerLogin_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _AuthService_ValidateToken_Handler,
		},
		{
			MethodName: "CreateAdminUser",
			Handler:    _AuthService_CreateAdminUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

const (
	InvoiceService_CreateInvoice_FullMethodName       = "/bread.InvoiceService/CreateInvoice"
	InvoiceService_GetInvoice_FullMethodName          = "/bread.InvoiceService/GetInvoice"
	InvoiceService_GetCustomerInvoices_FullMethodName = "/bread.InvoiceService/GetCustomerInvoices"
	InvoiceService_GetAllInvoices_FullMethodName      = "/bread.InvoiceService/GetAllInvoices"
)

// InvoiceServiceClient is the client API for InvoiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Invoice Service
type InvoiceServiceClient interface {
	CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	GetInvoice(ctx context.Context, in *InvoiceIdRequest, opts ...grpc.CallOption) (*Invoice, error)
	GetCustomerInvoices(ctx context.Context, in *CustomerInvoicesRequest, opts ...grpc.CallOption) (*InvoiceList, error)
	GetAllInvoices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*InvoiceList, error)
}

type invoiceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInvoiceServiceClient(cc grpc.ClientConnInterface) InvoiceServiceClient {
	return &invoiceServiceClient{cc}
}

func (c *invoiceServiceClient) CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, InvoiceService_CreateInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) GetInvoice(ctx context.Context, in *InvoiceIdRequest, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, InvoiceService_GetInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) GetCustomerInvoices(ctx context.Context, in *CustomerInvoicesRequest, opts ...grpc.CallOption) (*InvoiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvoiceList)
	err := c.cc.Invoke(ctx, InvoiceService_GetCustomerInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) GetAllInvoices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*InvoiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvoiceList)
	err := c.cc.Invoke(ctx, InvoiceService_GetAllInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InvoiceServiceServer is the server API for InvoiceService service.
// All implementations must embed UnimplementedInvoiceServiceServer
// for forward compatibility.
//
// Invoice Service
type InvoiceServiceServer interface {
	CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error)
	GetInvoice(context.Context, *InvoiceIdRequest) (*Invoice, error)
	GetCustomerInvoices(context.Context, *CustomerInvoicesRequest) (*InvoiceList, error)
	GetAllInvoices(context.Context, *Empty) (*InvoiceList, error)
	mustEmbedUnimplementedInvoiceServiceServer()
}

// UnimplementedInvoiceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInvoiceServiceServer struct{}

func (UnimplementedInvoiceServiceServer) CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) GetInvoice(context.Context, *InvoiceIdRequest) (*Invoice, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) GetCustomerInvoices(context.Context, *CustomerInvoicesRequest) (*InvoiceList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCustomerInvoices not implemented")
}
func (UnimplementedInvoiceServiceServer) GetAllInvoices(context.Context, *Empty) (*InvoiceList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllInvoices not implemented")
}
func (UnimplementedInvoiceServiceServer) mustEmbedUnimplementedInvoiceServiceServer() {}
func (UnimplementedInvoiceServiceServer) testEmbeddedByValue()                        {}

// UnsafeInvoiceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InvoiceServiceServer will
// result in compilation errors.
type UnsafeInvoiceServiceServer interface {
	mustEmbedUnimplementedInvoiceServiceServer()
}

func RegisterInvoiceServiceServer(s grpc.ServiceRegistrar, srv InvoiceServiceServer) {
	// If the following call panics, it indicates UnimplementedInvoiceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InvoiceService_ServiceDesc, srv)
}

func _InvoiceService_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_CreateInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).CreateInvoice(ctx, req.(*CreateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_GetInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvoiceIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).GetInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_GetInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).GetInvoice(ctx, req.(*InvoiceIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_GetCustomerInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerInvoicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).GetCustomerInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_GetCustomerInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).GetCustomerInvoices(ctx, req.(*CustomerInvoicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_GetAllInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).GetAllInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_GetAllInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).GetAllInvoices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// InvoiceService_ServiceDesc is the grpc.ServiceDesc for InvoiceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InvoiceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.InvoiceService",
	HandlerType: (*InvoiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateInvoice",
			Handler:    _InvoiceService_CreateInvoice_Handler,
		},
		{
			MethodName: "GetInvoice",
			Handler:    _InvoiceService_GetInvoice_Handler,
		},
		{
			MethodName: "GetCustomerInvoices",
			Handler:    _InvoiceService_GetCustomerInvoices_Handler,
		},
		{
			MethodName: "GetAllInvoices",
			Handler:    _InvoiceService_GetAllInvoices_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}

const (
	CustomerPortalService_GetMyOrders_FullMethodName     = "/bread.CustomerPortalService/GetMyOrders"
	CustomerPortalService_GetMyInvoices_FullMethodName   = "/bread.CustomerPortalService/GetMyInvoices"
	CustomerPortalService_GetOrderDetails_FullMethodName = "/bread.CustomerPortalService/GetOrderDetails"
)

// CustomerPortalServiceClient is the client API for CustomerPortalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Customer Portal Service
type CustomerPortalServiceClient interface {
	GetMyOrders(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerOrdersResponse, error)
	GetMyInvoices(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*InvoiceList, error)
	GetOrderDetails(ctx context.Context, in *BuyOrderIdRequest, opts ...grpc.CallOption) (*BuyOrderDetailsResponse, error)
}

type customerPortalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCustomerPortalServiceClient(cc grpc.ClientConnInterface) CustomerPortalServiceClient {
	return &customerPortalServiceClient{cc}
}

func (c *customerPortalServiceClient) GetMyOrders(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerOrdersResponse)
	err := c.cc.Invoke(ctx, CustomerPortalService_GetMyOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerPortalServiceClient) GetMyInvoices(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*InvoiceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InvoiceList)
	err := c.cc.Invoke(ctx, CustomerPortalService_GetMyInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerPortalServiceClient) GetOrderDetails(ctx context.Context, in *BuyOrderIdRequest, opts ...grpc.CallOption) (*BuyOrderDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyOrderDetailsResponse)
	err := c.cc.Invoke(ctx, CustomerPortalService_GetOrderDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerPortalServiceServer is the server API for CustomerPortalService service.
// All implementations must embed UnimplementedCustomerPortalServiceServer
// for forward compatibility.
//
// Customer Portal Service
type CustomerPortalServiceServer interface {
	GetMyOrders(context.Context, *CustomerIdRequest) (*CustomerOrdersResponse, error)
	GetMyInvoices(context.Context, *CustomerIdRequest) (*InvoiceList, error)
	GetOrderDetails(context.Context, *BuyOrderIdRequest) (*BuyOrderDetailsResponse, error)
	mustEmbedUnimplementedCustomerPortalServiceServer()
}

// UnimplementedCustomerPortalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCustomerPortalServiceServer struct{}

func (UnimplementedCustomerPortalServiceServer) GetMyOrders(context.Context, *CustomerIdRequest) (*CustomerOrdersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMyOrders not implemented")
}
func (UnimplementedCustomerPortalServiceServer) GetMyInvoices(context.Context, *CustomerIdRequest) (*InvoiceList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMyInvoices not implemented")
}
func (UnimplementedCustomerPortalServiceServer) GetOrderDetails(context.Context, *BuyOrderIdRequest) (*BuyOrderDetailsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOrderDetails not implemented")
}
func (UnimplementedCustomerPortalServiceServer) mustEmbedUnimplementedCustomerPortalServiceServer() {}
func (UnimplementedCustomerPortalServiceServer) testEmbeddedByValue()                               {}

// UnsafeCustomerPortalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CustomerPortalServiceServer will
// result in compilation errors.
type UnsafeCustomerPortalServiceServer interface {
	mustEmbedUnimplementedCustomerPortalServiceServer()
}

func RegisterCustomerPortalServiceServer(s grpc.ServiceRegistrar, srv CustomerPortalServiceServer) {
	// If the following call panics, it indicates UnimplementedCustomerPortalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CustomerPortalService_ServiceDesc, srv)
}

func _CustomerPortalService_GetMyOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerPortalServiceServer).GetMyOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerPortalService_GetMyOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerPortalServiceServer).GetMyOrders(ctx, req.(*CustomerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerPortalService_GetMyInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerPortalServiceServer).GetMyInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerPortalService_GetMyInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerPortalServiceServer).GetMyInvoices(ctx, req.(*CustomerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerPortalService_GetOrderDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyOrderIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerPortalServiceServer).GetOrderDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerPortalService_GetOrderDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerPortalServiceServer).GetOrderDetails(ctx, req.(*BuyOrderIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CustomerPortalService_ServiceDesc is the grpc.ServiceDesc for CustomerPortalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CustomerPortalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bread.CustomerPortalService",
	HandlerType: (*CustomerPortalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMyOrders",
			Handler:    _CustomerPortalService_GetMyOrders_Handler,
		},
		{
			MethodName: "GetMyInvoices",
			Handler:    _CustomerPortalService_GetMyInvoices_Handler,
		},
		{
			MethodName: "GetOrderDetails",
			Handler:    _CustomerPortalService_GetOrderDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/bread.proto",
}
